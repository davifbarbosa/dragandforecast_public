<section id="hero" class="hero section forcast">
  <div class="container-fluid">
    <%= render partial: 'shared/upgrade_plan_msg' %>
    <!-- Elementos fixos -->
    <div class="fixed-elements">
      <div class="buttons">
        <div class="number-format">
          <label><input type="radio" name="number-format" value="us" checked> Decimals Format (.)</label>
          <label><input type="radio" name="number-format" value="eu"> Decimals Format (,)</label>
        </div>
        <br>
        <div style="display: inline-flex; align-items: center; gap: 10px;">
          <%= form_with url: forecast_rows_path, local: true, html: { multipart: true, id: 'import-form', style: 'display: inline-block;' } do |form| %>
            <label for="upload-template" class="custom-button">Upload Template</label>
            <%= form.file_field :file, id: 'upload-template', accept: '.csv', class: 'd-none' %>
            <%= form.submit "Import template", class: 'd-none' %>
          <% end %>

          <%= form_with url: actuals_path, local: true, html: { multipart: true, id: 'actuals-import-form', style: 'display: inline-block;' } do |form| %>
            <label for="upload-actuals" class="custom-button">Upload de Actuals</label>
            <%= form.file_field :file, id: 'upload-actuals', accept: '.csv', class: 'd-none' %>
            <%= form.submit "Import actuals CSV", class: 'd-none' %>
          <% end %>

          <button class="custom-button" onclick="exportData()">Export DB (XLS)</button>
          <button type="button" class="custom-button" onclick="applyUpdates()">Apply Updates</button>

          <%= button_to 'Clear Forecast', destroy_all_forecast_rows_path,
                        local: false,
                        method: :delete,
                        data: { turbo: false, turbo_confirm: 'Are you sure you want to delete all forecast?' },
                        class: 'btn btn-danger' %>

          <%= button_to 'Clear Actuals', destroy_all_actuals_path,
                        local: false,
                        method: :delete,
                        data: { turbo: false, turbo_confirm: 'Are you sure you want to delete all forecast?' },
                        class: 'btn btn-danger' %>
        </div>
      </div>

      <div class="filter-container">
        <label for="filter-search">Search:</label>
        <input type="text" id="filter-search" oninput="searchFilterOptions()" placeholder="Search...">
        <div class="custom-dropdown">
          <button class="dropdown-btn" id="dropdown-btn-3m">Avg-1 ▼</button>
          <div class="dropdown-content" id="dropdown-content-3m"></div>
        </div>
        <div class="custom-dropdown">
          <button class="dropdown-btn" id="dropdown-btn-6m">Avg-2 ▼</button>
          <div class="dropdown-content" id="dropdown-content-6m"></div>
        </div>
        <br>
        <div class="controls">
          <div id="level-selector">
            <% default_level = if params[:product].present?
                                 'product'
                               elsif params[:subcategory].present?
                                 'subcategory'
                               elsif params[:category].present?
                                 'category'
                               else
                                 'product' # default selection
                               end %>

            <%= radio_button_tag 'level', 'product', default_level == 'product', class: 'level-radio', id: 'level_product' %>
            <%= label_tag 'level_product', 'Product' %>

            <%= radio_button_tag 'level', 'subcategory', default_level == 'subcategory', class: 'level-radio', id: 'level_subcategory' %>
            <%= label_tag 'level_subcategory', 'Sub-Category' %>

            <%= radio_button_tag 'level', 'category', default_level == 'category', class: 'level-radio', id: 'level_category' %>
            <%= label_tag 'level_category', 'Category' %>

          </div>
        </div>
        <label for="filter-select">Filter by:</label>
        <!-- Hidden containers to hold different select options -->
        <div id="type_products" class="d-none">
          <%= select_tag :product, options_for_select(@product_names), id: "product-select" %>
        </div>
        <div id="type_subcategories" class="d-none">
          <%= select_tag :subcategory, options_for_select(@subcategories), id: "subcategory-select" %>
        </div>
        <div id="type_categories" class="d-none">
          <%= select_tag :category, options_for_select(@categories), id: "category-select" %>
        </div>
        <div class="d-inline-flex align-items-center gap-2">
          <%= form_with url: forecast_rows_path, method: :get, local: true, id: 'filter-form', html: { class: "d-inline" } do %>
            <%= hidden_field_tag :level, params[:level] || 'product', id: 'level-hidden' %>
            <div id="filters_type">
              <!-- default select -->
              <%= select_tag :product, options_for_select(@product_names, params[:product]), id: "filter-select" %>
            </div>
            <%= submit_tag "Filter", class: 'd-none' %>
          <% end %>

          <button onclick="navigateFilter('previous')" class="custom-button">Previous</button>
          <button onclick="navigateFilter('next')" class="custom-button">Next</button>
        </div>
      </div>
      <div class="color-controls">
        <label>Green Periods:</label>
        <input type="number" id="green-periods" value="12" min="0" max="36" step="1">

        <label>Blue Periods:</label>
        <input type="number" id="blue-periods" value="12" min="0" max="36" step="1">

        <label>Red Periods:</label>
        <input type="number" id="red-periods" value="12" min="0" max="36" step="1">

        <button onclick="updateChartColors()">Update Colors</button>
      </div>
      <div class="totals-container">
        <% @totals_by_year.each_with_index do |total, index| %>
          <div class="total highlight-<%=index.even? ? 'gray' : 'green' %>" id="total-motors-<%=total[0] %>">TOTALS <%=total[0] %>:<br> <span><%=total[1] %></span></div>
        <% end %>
        <div class="total highlight-gray" id="total-2024">FILTERED 2024:<br> <span>0</span></div>
        <div class="total highlight-green" id="total-2025">FILTERED 2025:<br> <span>0</span></div>
        <div class="total highlight-gray" id="total-2026">FILTERED 2026:<br> <span>0</span></div>
      </div>
    </div>
    <div class="scrollable-content">
      <div id="chart-container">
        <canvas id="forecast-chart" height="300"></canvas>
      </div>

      <div class="data-table-wrapper">
        <table class="data-table">
          <thead id="table-headers">
          <tr>
            <% @forecast_rows_header.each do |key| %>
              <th><%= key %></th>
            <% end %>
          </tr>
          </thead>
          <tbody id="data-table-body">
          <% @forecast_rows.each do |record| %>
            <tr>
              <% @forecast_rows_header.each do |key| %>
                <td><%= record.data[key] %></td>
              <% end %>
            </tr>
          <% end %>
          </tbody>
        </table>
      </div>

      <div class="data-table-wrapper">
        <h3>Tabela Original (Backup)</h3>
        <table class="data-table">
          <thead id="original-table-headers">
          <tr>
            <% @forecast_rows_backup_header.each do |key| %>
              <th><%= key %></th>
            <% end %>
          </tr>
          </thead>
          <tbody id="original-table-body">
          <% @forecast_rows_backup.each do |record| %>
            <tr>
              <% @forecast_rows_backup_header.each do |key| %>
                <td><%= record.data[key] %></td>
              <% end %>
            </tr>
          <% end %>
          </tbody>
        </table>
      </div>

      <div class="data-table-wrapper">
        <h3>Tabela de Diferenças</h3>
        <table class="data-table">
          <thead id="difference-table-headers"></thead>
          <tr>
            <% @all_keys.each do |key| %>
              <th><%= key %></th>
            <% end %>
          </tr>
          </thead>
          <tbody id="difference-table-body">
          <% @comparison_data.each do |row| %>
            <tr>
              <% row[:values].each do |diff| %>
                <td style="color:
                  <%= diff.is_a?(Numeric) ? (diff > 0 ? 'green' : (diff < 0 ? 'red' : 'black')) : 'orange' %>;">
                  <%= diff.is_a?(Numeric) ? (diff == 0 ? '0' : (diff > 0 ? "+#{diff}" : diff)) : diff %>
                </td>
              <% end %>
            </tr>
          <% end %>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</section>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.17.0/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
<script>

    function searchFilterOptions() {
        const input = document.getElementById("filter-search");
        const filter = input.value.toLowerCase();
        const select = document.getElementById("filter-select");

        if (!select) return;

        // Show/hide options
        for (let i = 0; i < select.options.length; i++) {
            const option = select.options[i];
            const text = option.text.toLowerCase();

            if (text.includes(filter)) {
                option.style.display = "";
            } else {
                option.style.display = "none";
            }
        }
    }
    document.addEventListener('DOMContentLoaded', function () {
        const radios = document.querySelectorAll('.level-radio');
        const filtersContainer = document.getElementById('filters_type');

        radios.forEach(radio => {
            radio.addEventListener('change', function () {
                let sourceId = '';
                switch (this.value) {
                    case 'product':
                        sourceId = 'type_products';
                        break;
                    case 'subcategory':
                        sourceId = 'type_subcategories';
                        break;
                    case 'category':
                        sourceId = 'type_categories';
                        break;
                }

                const sourceDiv = document.getElementById(sourceId);
                if (sourceDiv) {
                    filtersContainer.innerHTML = sourceDiv.innerHTML;
                }
            });
        });
    });
    function navigateFilter(direction) {
        const filtersContainer = document.getElementById('filters_type');
        const select = filtersContainer.querySelector('select'); // Finds current active select

        if (!select) return;

        const options = select.options;
        let selectedIndex = select.selectedIndex;

        if (direction === 'next' && selectedIndex < options.length - 1) {
            select.selectedIndex = selectedIndex + 1;
        } else if (direction === 'previous' && selectedIndex > 0) {
            select.selectedIndex = selectedIndex - 1;
        }

        document.getElementById('filter-form').submit();
    }
    document.addEventListener('DOMContentLoaded', function () {
        const radios = document.querySelectorAll('.level-radio');
        const filtersContainer = document.getElementById('filters_type');
        const levelHidden = document.getElementById('level-hidden');

        function updateSelectFromRadio(value) {
            let sourceId = '';
            let selectedValue = ''; // Will fetch from URL params

            switch (value) {
                case 'product':
                    sourceId = 'type_products';
                    selectedValue = new URLSearchParams(window.location.search).get('product');
                    break;
                case 'subcategory':
                    sourceId = 'type_subcategories';
                    selectedValue = new URLSearchParams(window.location.search).get('subcategory');
                    break;
                case 'category':
                    sourceId = 'type_categories';
                    selectedValue = new URLSearchParams(window.location.search).get('category');
                    break;
            }

            const sourceDiv = document.getElementById(sourceId);
            if (sourceDiv) {
                filtersContainer.innerHTML = sourceDiv.innerHTML;

                const newSelect = filtersContainer.querySelector('select');
                if (newSelect) {
                    newSelect.id = 'filter-select';

                    // Restore selected option
                    if (selectedValue) {
                        Array.from(newSelect.options).forEach(option => {
                            if (option.value === selectedValue) {
                                option.selected = true;
                            }
                        });
                    }

                    // Submit on change
                    newSelect.addEventListener("change", function () {
                        this.form.submit();
                    });
                }
            }

            // Set the hidden input value
            if (levelHidden) levelHidden.value = value;
        }

        // Apply listeners on radio buttons
        radios.forEach(radio => {
            radio.addEventListener('change', function () {
                updateSelectFromRadio(this.value);
            });
        });

        // On page load: find the checked radio and update
        const checkedRadio = document.querySelector('.level-radio:checked');
        if (checkedRadio) {
            updateSelectFromRadio(checkedRadio.value);
        }
    });


    document.addEventListener("DOMContentLoaded", function () {
        const fileInput = document.getElementById("upload-template");

        fileInput.addEventListener("change", function () {
            if (fileInput.files.length > 0) {
                document.getElementById("import-form").submit();
            }
        });

        const actualfileInput = document.getElementById("upload-actuals");

        actualfileInput.addEventListener("change", function () {
            if (actualfileInput.files.length > 0) {
                document.getElementById("actuals-import-form").submit();
            }
        });


    });
    let actuals = [];
    let isDarkMode = false;
    let originalValue = null;
    const sumOfAverages1 = <%= @sum_of_averages1 %>;
    const sumOfAverages2 = <%= @sum_of_averages2 %>;
    const rawData = <%= raw(@forecast_rows.to_json) %>;
    const labels = Object.keys(rawData[0].data);
    const values = labels.map(key => parseFloat(rawData[0].data[key]));

    const actualsrawData = <%= @actuals.present? ? raw(@actuals.to_json) : '[]' %>;
    if (actualsrawData.length > 0){
        const actual_labels = Object.keys(actualsrawData[0].data);
        actuals = actual_labels.map(key => parseFloat(actualsrawData[0].data[key]));
    }else {
        actuals =  []
    }
    <!--    const forecast_rows_backup = <%#= raw(@forecast_rows_backup.to_json) %>;-->
    // const labels_backup = Object.keys(forecast_rows_backup[0].data);// Create independent backup data
    // const original_backup = labels_backup.map(key => parseFloat(forecast_rows_backup[0].data[key]));
    const rowId = rawData[0].id;

    const split1 = 12;
    const split2 = 24;
    const colors = values.map((_, i) => {
        if (i < split1) return 'green';
        if (i < split2) return 'blue';
        return 'red';
    });

    new Chart(document.getElementById('forecast-chart'), {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Actual & Forecast',
                    data: <%=@totals_by_column.to_h.values %>, // This one is draggable
                    borderColor: colors,
                    segment: {
                        borderColor: ['green', 'red', 'blue'],
                    },
                    borderWidth: 2,
                    fill: false,
                    pointBackgroundColor: 'white',
                    pointBorderColor: colors,
                    pointRadius: 5,
                    tension: 0.4
                },
                {
                    label: 'Original Backup',
                    data: <%=@totals_backup_by_column.to_h.values %>, // Cloned, not draggable
                    borderColor: 'gray',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0,
                    datalabels: {
                        display: false
                    }
                },
                {
                    type: 'bar',
                    label: 'Actuals',
                    data: <%=@actual_columns.to_h.values %>,
                    backgroundColor: 'rgba(173, 216, 230, 0.7)', // light blue
                    datalabels: {
                        display: false // 👈 Hides values for this dataset only
                    }
                },
                {
                    label: 'Avg-1',
                    data: Array(labels.length).fill(sumOfAverages1),
                    borderColor: 'blue',
                    borderWidth: 2,
                    borderDash: [3, 3],
                    pointRadius: 0,
                    fill: false,
                    datalabels: {
                        display: true,
                        formatter: function() {
                            return sumOfAverages1.toFixed(2);
                        },
                        align: 'right',
                        anchor: 'right'
                    },
                    datalabels: {
                        display: false
                    }
                },
                {
                    label: 'Avg-2',
                    data: Array(labels.length).fill(sumOfAverages2),
                    borderColor: 'red',
                    borderWidth: 2,
                    borderDash: [3, 3],
                    pointRadius: 0,
                    fill: false,
                    datalabels: {
                        display: true,
                        formatter: function() {
                            return sumOfAverages2.toFixed(2);
                        },
                        align: 'right',
                        anchor: 'right'
                    },
                    datalabels: {
                        display: false
                    }
                },
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            layout: {
                padding: {
                    top: 50,
                    bottom: 30
                }
            },
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        boxWidth: 15,
                        font: { size: 12 },
                        color: isDarkMode ? "#ffffff" : "#000000"
                    }
                },
                tooltip: {
                    backgroundColor: isDarkMode ? "#333" : "#ffffff",
                    titleColor: isDarkMode ? "#ffffff" : "#000000",
                    bodyColor: isDarkMode ? "#ffffff" : "#000000",
                    borderColor: isDarkMode ? "#666" : "#ddd",
                    borderWidth: 1
                },
                datalabels: {
                    color: isDarkMode ? "#ffffff" : "#000000",
                    anchor: 'end',
                    align: 'top',
                    formatter: value => Math.round(value).toLocaleString(),
                    font: { size: 9, weight: 'bold' },
                    rotation: -60
                },
                dragData: {
                    round: 1,
                    showTooltip: true,
                    onDragStart:(e, datasetIndex, index, value) =>  {
                        if (datasetIndex !== 0) return false;

                        originalValue = value; // Save the starting value
                        return true;
                    },
                    onDragEnd: (e, datasetIndex, index, value) => {
                        if (datasetIndex !== 0 || originalValue === null) return;
                        const percentChange = ((value - originalValue) / originalValue) * 100;
                        const key = labels[index];
                        rawData[0].data[key] = value;
                        fetch(`/forecast_rows/${rowId}`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-Token': document.querySelector("[name='csrf-token']").content
                            },
                            body: JSON.stringify({
                                data: rawData[0].data,
                                changed_key: key,
                                percent_change: percentChange.toFixed(2)
                            })
                        }).then(response => {
                            if (!response.ok) {
                                alert("Failed to save updated value.");
                            }
                        });
                    }
                }
            },
            scales: {
                x: {
                    title: {
                        display: false,
                        text: 'Period',
                        color: isDarkMode ? "#ffffff" : "#000000"
                    },
                    ticks: {
                        maxRotation: 60,
                        minRotation: 30,
                        color: isDarkMode ? "#ffffff" : "#000000"
                    },
                    grid: {
                        display: false,
                        color: isDarkMode ? "#444" : "#ddd"
                    }
                },
                y: {
                    title: {
                        display: false,
                        text: 'Volume',
                        color: isDarkMode ? "#ffffff" : "#000000"
                    },
                    beginAtZero: true,
                    ticks: {
                        callback: value => Math.round(value).toLocaleString(),
                        color: isDarkMode ? "#ffffff" : "#000000"
                    },
                    grid: {
                        display: false,
                        color: isDarkMode ? "#444" : "#ddd"
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });
</script>
<div class="loading-popup" style="display: none;">
  <p>Processing data... Please wait.</p>
</div>
<div class="hidden-content">
  <div id="tooltip" class="custom-tooltip" style="display: none;"></div>
</div>