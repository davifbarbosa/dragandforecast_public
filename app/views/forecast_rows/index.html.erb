<section id="hero" class="hero hero1 section forcast">
  <div class="container-fluid">
    <%= render partial: 'shared/upgrade_plan_msg' %>
    <!-- Elementos fixos -->
    <div class="fixed-elements">
      <%= render partial: 'shared/form_buttons' %>
      <%= render partial: 'shared/filters' %>
      <%= render partial: 'shared/color_filters' %>
      <%= render partial: 'shared/total' %>
    </div>
    <div class="scrollable-content">
      <%= render partial: 'shared/chart' %>
      <%= render partial: 'shared/modify_table' %>
      <%= render partial: 'shared/backup_table' %>
      <%= render partial: 'shared/difference_table' %>
    </div>
  </div>
</section>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.17.0/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        document.querySelectorAll(".auto-submit-checkbox").forEach(function (checkbox) {
            checkbox.addEventListener("change", function () {
                document.getElementById("filter-form").submit();
            });
        });
    });
    function toggleDropdown(dropdownId) {
        const dropdown = document.getElementById(dropdownId);
        dropdown.style.display = (dropdown.style.display === "block") ? "none" : "block";
    }
    window.addEventListener("click", function (event) {
        if (!event.target.closest(".custom-dropdown")) {
            document.getElementById("dropdown-content-3m").style.display = "none";
            document.getElementById("dropdown-content-6m").style.display = "none";
        }
    });

    // Adiciona eventos de clique aos bot√µes do dropdown
    document.getElementById("dropdown-btn-3m").addEventListener("click", function (event) {
        event.stopPropagation(); // Impede que o clique feche o dropdown imediatamente
        toggleDropdown("dropdown-content-3m");
    });

    document.getElementById("dropdown-btn-6m").addEventListener("click", function (event) {
        event.stopPropagation();
        toggleDropdown("dropdown-content-6m");
    });
    function searchFilterOptions() {
        const input = document.getElementById("filter-search");
        const filter = input.value.toLowerCase();
        const select = document.getElementById("filter-select");

        if (!select) return;

        // Show/hide options
        for (let i = 0; i < select.options.length; i++) {
            const option = select.options[i];
            const text = option.text.toLowerCase();

            if (text.includes(filter)) {
                option.style.display = "";
            } else {
                option.style.display = "none";
            }
        }
    }
    document.addEventListener('DOMContentLoaded', function () {
        const radios = document.querySelectorAll('.level-radio');
        const filtersContainer = document.getElementById('filters_type');

        radios.forEach(radio => {
            radio.addEventListener('change', function () {
                let sourceId = '';
                switch (this.value) {
                    case 'product':
                        sourceId = 'type_products';
                        break;
                    case 'subcategory':
                        sourceId = 'type_subcategories';
                        break;
                    case 'category':
                        sourceId = 'type_categories';
                        break;
                }

                const sourceDiv = document.getElementById(sourceId);
                if (sourceDiv) {
                    filtersContainer.innerHTML = sourceDiv.innerHTML;
                }
            });
        });
    });
    function navigateFilter(direction) {
        const filtersContainer = document.getElementById('filters_type');
        const select = filtersContainer.querySelector('select'); // Finds current active select

        if (!select) return;

        const options = select.options;
        let selectedIndex = select.selectedIndex;

        if (direction === 'next' && selectedIndex < options.length - 1) {
            select.selectedIndex = selectedIndex + 1;
        } else if (direction === 'previous' && selectedIndex > 0) {
            select.selectedIndex = selectedIndex - 1;
        }

        document.getElementById('filter-form').submit();
    }
    document.addEventListener('DOMContentLoaded', function () {
        const radios = document.querySelectorAll('.level-radio');
        const filtersContainer = document.getElementById('filters_type');
        const levelHidden = document.getElementById('level-hidden');

        function updateSelectFromRadio(value) {
            let sourceId = '';
            let selectedValue = ''; // Will fetch from URL params

            switch (value) {
                case 'product':
                    sourceId = 'type_products';
                    selectedValue = new URLSearchParams(window.location.search).get('product');
                    break;
                case 'subcategory':
                    sourceId = 'type_subcategories';
                    selectedValue = new URLSearchParams(window.location.search).get('subcategory');
                    break;
                case 'category':
                    sourceId = 'type_categories';
                    selectedValue = new URLSearchParams(window.location.search).get('category');
                    break;
            }

            const sourceDiv = document.getElementById(sourceId);
            if (sourceDiv) {
                filtersContainer.innerHTML = sourceDiv.innerHTML;

                const newSelect = filtersContainer.querySelector('select');
                if (newSelect) {
                    newSelect.id = 'filter-select';

                    // Restore selected option
                    if (selectedValue) {
                        Array.from(newSelect.options).forEach(option => {
                            if (option.value === selectedValue) {
                                option.selected = true;
                            }
                        });
                    }

                    // Submit on change
                    newSelect.addEventListener("change", function () {
                        this.form.submit();
                    });
                }
            }

            // Set the hidden input value
            if (levelHidden) levelHidden.value = value;
        }

        // Apply listeners on radio buttons
        radios.forEach(radio => {
            radio.addEventListener('change', function () {
                updateSelectFromRadio(this.value);
            });
        });

        // On page load: find the checked radio and update
        const checkedRadio = document.querySelector('.level-radio:checked');
        if (checkedRadio) {
            updateSelectFromRadio(checkedRadio.value);
        }
    });
    document.addEventListener("DOMContentLoaded", function () {
        const fileInput = document.getElementById("upload-template");

        fileInput.addEventListener("change", function () {
            if (fileInput.files.length > 0) {
                document.getElementById("import-form").submit();
            }
        });

        const actualfileInput = document.getElementById("upload-actuals");

        actualfileInput.addEventListener("change", function () {
            if (actualfileInput.files.length > 0) {
                document.getElementById("actuals-import-form").submit();
            }
        });


    });
    let actuals = [];
    let isDarkMode = false;
    let originalValue = null;
    const sumOfAverages1 = <%= @average1 ? @average1 : '[]' %>;
    const sumOfAverages2 = <%= @average2 ? @average2 : '[]' %>;
    const rawData = <%= raw(@forecast_rows.to_json) %>;
    const labels = Object.keys(rawData[0].data);
    const values = labels.map(key => parseFloat(rawData[0].data[key]));

    const actualsrawData = <%= @actuals.present? ? raw(@actuals.to_json) : '[]' %>;
    if (actualsrawData.length > 0){
        const actual_labels = Object.keys(actualsrawData[0].data);
        actuals = actual_labels.map(key => parseFloat(actualsrawData[0].data[key]));
    }else {
        actuals =  []
    }

    const rowId = rawData[0].id;
    const split1 = 12;
    const split2 = 24;
    const colors = values.map((_, i) => {
        if (i < split1) return 'green';
        if (i < split2) return 'blue';
        return 'red';
    });

    new Chart(document.getElementById('forecast-chart'), {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Actual & Forecast',
                    data: <%=@totals_by_column.to_h.values %>, // This one is draggable
                    borderColor: colors,
                    segment: {
                        borderColor: ['green', 'red', 'blue'],
                    },
                    borderWidth: 2,
                    fill: false,
                    pointBackgroundColor: 'white',
                    pointBorderColor: colors,
                    pointRadius: 5,
                    tension: 0.4
                },
                {
                    label: 'Original Backup',
                    data: <%=@totals_backup_by_column.to_h.values %>, // Cloned, not draggable
                    borderColor: 'gray',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0,
                    datalabels: {
                        display: false
                    }
                },
                {
                    type: 'bar',
                    label: 'Actuals',
                    data: <%=@actual_columns.to_h.values %>,
                    backgroundColor: 'rgba(173, 216, 230, 0.7)', // light blue
                    datalabels: {
                        display: false // üëà Hides values for this dataset only
                    }
                },
                {
                    label: 'Avg-1',
                    data: Array(labels.length).fill(sumOfAverages1),
                    borderColor: 'blue',
                    borderWidth: 2,
                    borderDash: [3, 3],
                    pointRadius: 0,
                    fill: false,
                    datalabels: {
                        display: true,
                        formatter: function() {
                            return sumOfAverages1.toFixed(2);
                        },
                        align: 'right',
                        anchor: 'right'
                    },
                    datalabels: {
                        display: false
                    }
                },
                {
                    label: 'Avg-2',
                    data: Array(labels.length).fill(sumOfAverages2),
                    borderColor: 'red',
                    borderWidth: 2,
                    borderDash: [3, 3],
                    pointRadius: 0,
                    fill: false,
                    datalabels: {
                        display: true,
                        formatter: function() {
                            return sumOfAverages2.toFixed(2);
                        },
                        align: 'right',
                        anchor: 'right'
                    },
                    datalabels: {
                        display: false
                    }
                },
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    top: 50,
                    bottom: 30
                }
            },
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        boxWidth: 15,
                        font: { size: 12 },
                        color: isDarkMode ? "#ffffff" : "#000000"
                    }
                },
                tooltip: {
                    backgroundColor: isDarkMode ? "#333" : "#ffffff",
                    titleColor: isDarkMode ? "#ffffff" : "#000000",
                    bodyColor: isDarkMode ? "#ffffff" : "#000000",
                    borderColor: isDarkMode ? "#666" : "#ddd",
                    borderWidth: 1
                },
                datalabels: {
                    color: isDarkMode ? "#ffffff" : "#000000",
                    anchor: 'end',
                    align: 'top',
                    formatter: value => Math.round(value).toLocaleString(),
                    font: { size: 9, weight: 'bold' },
                    rotation: -60
                },
                dragData: {
                    round: 1,
                    showTooltip: true,
                    onDragStart:(e, datasetIndex, index, value) =>  {
                        if (datasetIndex !== 0) return false;

                        originalValue = value; // Save the starting value
                        return true;
                    },
                    onDragEnd: (e, datasetIndex, index, value) => {
                        if (datasetIndex !== 0 || originalValue === null) return;
                        const percentChange = ((value - originalValue) / originalValue) * 100;
                        const key = labels[index];
                        rawData[0].data[key] = value;
                        fetch(`/forecast_rows/${rowId}`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-Token': document.querySelector("[name='csrf-token']").content
                            },
                            body: JSON.stringify({
                                data: rawData[0].data,
                                changed_key: key,
                                percent_change: percentChange.toFixed(2)
                            })
                        }).then(response => {
                            if (!response.ok) {
                                alert("Failed to save updated value.");
                            }
                        });
                    }
                }
            },
            scales: {
                x: {
                    title: {
                        display: false,
                        text: 'Period',
                        color: isDarkMode ? "#ffffff" : "#000000"
                    },
                    ticks: {
                        maxRotation: 60,
                        minRotation: 30,
                        color: isDarkMode ? "#ffffff" : "#000000"
                    },
                    grid: {
                        display: false,
                        color: isDarkMode ? "#444" : "#ddd"
                    }
                },
                y: {
                    title: {
                        display: false,
                        text: 'Volume',
                        color: isDarkMode ? "#ffffff" : "#000000"
                    },
                    beginAtZero: true,
                    ticks: {
                        callback: value => Math.round(value).toLocaleString(),
                        color: isDarkMode ? "#ffffff" : "#000000"
                    },
                    grid: {
                        display: false,
                        color: isDarkMode ? "#444" : "#ddd"
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });
</script>
<div class="loading-popup" style="display: none;">
  <p>Processing data... Please wait.</p>
</div>
<div class="hidden-content">
  <div id="tooltip" class="custom-tooltip" style="display: none;"></div>
</div>